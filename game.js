// ÈÅäÊà≤Â∏∏Èáè
const GRID_SIZE = 16;
const CELL_SIZE = 50;
const BLUE_CELLS = 5;
const RED_CELLS = 5;

// ËßíËâ≤È°ûÂûãÊûöËàâ
const CHARACTER_TYPES = {
    SUNFLOWER: 'sunflower',
    WALL: 'wall',
    CANNON: 'cannon',
    CAT: 'cat',
    SWORD_CAT: 'swordCat'
};

// ËßíËâ≤Ë®≠ÂÆö
const CHARACTER_CONFIG = {
    [CHARACTER_TYPES.SUNFLOWER]: {
        cost: 2,
        health: 5,
        moneyGeneration: 1,
        generationInterval: 2000,
        isMovable: false,
        symbol: 'üåª'
    },
    [CHARACTER_TYPES.WALL]: {
        cost: 5,
        health: 30,
        isMovable: false,
        symbol: 'üß±'
    },
    [CHARACTER_TYPES.CANNON]: {
        cost: 5,
        health: 4,
        attack: 1,
        range: 9,
        fireRate: 1,
        bulletSpeed: 1,
        isMovable: false,
        symbol: 'üí£'
    },
    [CHARACTER_TYPES.CAT]: {
        cost: 2,
        health: 12,
        attack: 2,
        speed: 1,
        isMovable: true,
        symbol: 'üê±'
    },
    [CHARACTER_TYPES.SWORD_CAT]: {
        cost: 3,
        health: 10,
        attack: 3,
        speed: 1,
        isMovable: true,
        symbol: '‚öîÔ∏è'
    }
};

// Âú®CHARACTER_TYPESÂæåÊ∑ªÂä†ÊåâÈçµÊò†Â∞Ñ
const KEY_MAPPINGS = {
    BLUE: {
        'q': CHARACTER_TYPES.SUNFLOWER,
        'w': CHARACTER_TYPES.WALL,
        'e': CHARACTER_TYPES.CANNON,
        'r': CHARACTER_TYPES.CAT,
        't': CHARACTER_TYPES.SWORD_CAT,
        'a': 0, 's': 1, 'd': 2, 'f': 3, 'g': 4 // ‰ΩçÁΩÆÈÅ∏Êìá
    },
    RED: {
        '=': CHARACTER_TYPES.SUNFLOWER,
        '-': CHARACTER_TYPES.WALL,
        '0': CHARACTER_TYPES.CANNON,
        '9': CHARACTER_TYPES.CAT,
        '8': CHARACTER_TYPES.SWORD_CAT,
        '\\': 15, ']': 14, 'p': 13, 'o': 12, 'i': 11 // ‰ΩçÁΩÆÈÅ∏Êìá
    }
};

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = GRID_SIZE * CELL_SIZE;
        this.canvas.height = CELL_SIZE;
        
        this.grid = new Array(GRID_SIZE).fill(null).map(() => ({
            fixed: null,
            movable: null
        }));
        
        this.blueMoney = 10;
        this.redMoney = 10;
        
        this.setupEventListeners();
        this.gameLoop();
        
        // Ê∑ªÂä†Êñ∞ÁöÑÂ±¨ÊÄß
        this.selectedPosition = {
            BLUE: null,
            RED: null
        };
        this.characters = [];
        this.lastMoneyGeneration = Date.now();
        this.lastUpdate = Date.now();
        this.bullets = []; // Êñ∞Â¢ûÂ≠êÂΩàÈô£Âàó
    }

    setupEventListeners() {
        document.addEventListener('keydown', (e) => {
            this.handleKeyPress(e.key.toLowerCase());
        });
    }

    handleKeyPress(key) {
        // ËóçÊñπÈÅ∏Êìá‰ΩçÁΩÆ
        if (KEY_MAPPINGS.BLUE[key] !== undefined) {
            if (['a', 's', 'd', 'f', 'g'].includes(key)) {
                this.selectedPosition.BLUE = KEY_MAPPINGS.BLUE[key];
            } else {
                this.placeCharacter('BLUE', KEY_MAPPINGS.BLUE[key]);
            }
        }
        
        // Á¥ÖÊñπÈÅ∏Êìá‰ΩçÁΩÆ
        if (KEY_MAPPINGS.RED[key] !== undefined) {
            if (['\\', ']', 'p', 'o', 'i'].includes(key)) {
                this.selectedPosition.RED = KEY_MAPPINGS.RED[key];
            } else {
                this.placeCharacter('RED', KEY_MAPPINGS.RED[key]);
            }
        }
    }

    placeCharacter(team, characterType) {
        const position = this.selectedPosition[team];
        if (position === null) return;

        const config = CHARACTER_CONFIG[characterType];
        const money = team === 'BLUE' ? this.blueMoney : this.redMoney;
        
        if (money < config.cost) return;

        // Ê™¢Êü•‰ΩçÁΩÆÊòØÂê¶ÂêàÊ≥ï
        if (team === 'BLUE' && position >= BLUE_CELLS) return;
        if (team === 'RED' && position < GRID_SIZE - RED_CELLS) return;

        // Ê™¢Êü•Ê†ºÂ≠êÊòØÂê¶Â∑≤Ë¢´Âç†Áî®
        const existingFixed = this.grid[position].fixed;
        const existingMovable = this.grid[position].movable;
        
        if (config.isMovable && existingMovable) return;
        if (!config.isMovable && existingFixed) return;

        // ÂâµÂª∫Êñ∞ËßíËâ≤
        const character = {
            type: characterType,
            team: team,
            position: position,
            health: config.health,
            lastAttack: Date.now(),
            lastMove: Date.now(),
            lastMoneyGeneration: Date.now(),
            ...config
        };

        // Êõ¥Êñ∞ÈáëÈå¢
        if (team === 'BLUE') {
            this.blueMoney -= config.cost;
        } else {
            this.redMoney -= config.cost;
        }

        // ÊîæÁΩÆËßíËâ≤
        if (config.isMovable) {
            this.grid[position].movable = character;
        } else {
            this.grid[position].fixed = character;
        }
        
        this.characters.push(character);
        this.updateMoneyDisplay();
    }

    updateMoneyDisplay() {
        document.getElementById('blueMoneyText').textContent = this.blueMoney;
        document.getElementById('redMoneyText').textContent = this.redMoney;
    }

    gameLoop() {
        this.update();
        this.draw();
        this.animationFrame = requestAnimationFrame(() => this.gameLoop());
    }

    update() {
        const currentTime = Date.now();
        const deltaTime = (currentTime - this.lastUpdate) / 1000; // ËΩâÊèõÁÇ∫Áßí
        this.lastUpdate = currentTime;

        // ÁîüÊàêÈáëÈå¢
        if (currentTime - this.lastMoneyGeneration >= 2000) {
            this.characters.forEach(character => {
                if (character.type === CHARACTER_TYPES.SUNFLOWER) {
                    if (character.team === 'BLUE') {
                        this.blueMoney += character.moneyGeneration;
                    } else {
                        this.redMoney += character.moneyGeneration;
                    }
                }
            });
            this.lastMoneyGeneration = currentTime;
            this.updateMoneyDisplay();
        }
        
        // ËôïÁêÜÊà∞È¨•
        this.handleCombat(currentTime);
        
        // Êõ¥Êñ∞Â≠êÂΩà
        this.updateBullets(deltaTime);
        
        // ËôïÁêÜÁßªÂãïËßíËâ≤ÁöÑÁßªÂãï
        this.characters.forEach(character => {
            if (!character.isMovable) return;
            
            const currentCell = this.grid[character.position];
            if (currentCell.movable !== character) return; // Á¢∫‰øùËßíËâ≤‰ªçÂú®Âéü‰ΩçÁΩÆ
            
            // Ê™¢Êü•ÊòØÂê¶ÂèØ‰ª•ÁßªÂãï
            if (currentTime - character.lastMove < 1000 / character.speed) return;
            
            const nextPosition = character.team === 'BLUE' ? 
                character.position + 1 : 
                character.position - 1;
            
            // Ê™¢Êü•ÊòØÂê¶Âà∞ÈÅîÂãùÂà©Ê¢ù‰ª∂
            if (this.checkVictoryCondition(character, nextPosition)) {
                this.endGame(character.team);
                return;
            }

            // Ê™¢Êü•‰∏ã‰∏ÄÂÄã‰ΩçÁΩÆÊòØÂê¶ÂèØ‰ª•ÁßªÂãï
            if (this.canMoveTo(character, nextPosition)) {
                // ÂæûÁï∂Ââç‰ΩçÁΩÆÁßªÈô§
                currentCell.movable = null;
                
                // ÁßªÂãïÂà∞Êñ∞‰ΩçÁΩÆ
                this.grid[nextPosition].movable = character;
                character.position = nextPosition;
                character.lastMove = currentTime;
            }
        });
    }

    canMoveTo(character, position) {
        // Ê™¢Êü•ÊòØÂê¶Ë∂ÖÂá∫ÈÇäÁïå
        if (position < 0 || position >= GRID_SIZE) return false;

        const targetCell = this.grid[position];
        
        // Â¶ÇÊûúÊòØÊïµÊñπËßíËâ≤Ôºå‰∏çËÉΩÁ©øÈÅé
        if (targetCell.fixed && targetCell.fixed.team !== character.team) return false;
        if (targetCell.movable && targetCell.movable.team !== character.team) return false;

        return true;
    }

    checkVictoryCondition(character, nextPosition) {
        if (character.team === 'BLUE' && nextPosition >= GRID_SIZE - RED_CELLS) {
            return true;
        }
        if (character.team === 'RED' && nextPosition < BLUE_CELLS) {
            return true;
        }
        return false;
    }

    endGame(winner) {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.font = '48px Arial';
        this.ctx.fillStyle = winner === 'BLUE' ? 'blue' : 'red';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(
            `${winner === 'BLUE' ? 'ËóçÊñπ' : 'Á¥ÖÊñπ'}ÂãùÂà©ÔºÅ`,
            this.canvas.width / 2,
            this.canvas.height / 2
        );
        
        // ÂÅúÊ≠¢ÈÅäÊà≤Âæ™Áí∞
        cancelAnimationFrame(this.animationFrame);
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.drawGrid();
        this.drawCharacters();
        this.drawBullets();
    }

    drawGrid() {
        for (let i = 0; i < GRID_SIZE; i++) {
            this.ctx.beginPath();
            this.ctx.strokeStyle = 'black';
            this.ctx.rect(i * CELL_SIZE, 0, CELL_SIZE, CELL_SIZE);
            this.ctx.stroke();
            
            // Ê®ôË®òËóçÊñπÂçÄÂüü
            if (i < BLUE_CELLS) {
                this.ctx.fillStyle = 'rgba(0, 0, 255, 0.1)';
                this.ctx.fillRect(i * CELL_SIZE, 0, CELL_SIZE, CELL_SIZE);
            }
            // Ê®ôË®òÁ¥ÖÊñπÂçÄÂüü
            if (i >= GRID_SIZE - RED_CELLS) {
                this.ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                this.ctx.fillRect(i * CELL_SIZE, 0, CELL_SIZE, CELL_SIZE);
            }
        }
    }

    drawCharacters() {
        for (let i = 0; i < GRID_SIZE; i++) {
            const cell = this.grid[i];
            const x = i * CELL_SIZE;
            
            if (cell.fixed) {
                this.drawCharacter(cell.fixed, x, 0);
            }
            if (cell.movable) {
                this.drawCharacter(cell.movable, x, 0);
            }
        }
    }

    drawCharacter(character, x, y) {
        this.ctx.font = '30px Arial';
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        
        // Áπ™Ë£ΩËßíËâ≤Á¨¶Ëôü
        this.ctx.fillText(
            character.symbol,
            x + CELL_SIZE / 2,
            y + CELL_SIZE / 2
        );

        // Áπ™Ë£ΩË°ÄÈáè
        this.ctx.font = '12px Arial';
        this.ctx.fillStyle = character.team === 'BLUE' ? 'blue' : 'red';
        this.ctx.fillText(
            character.health,
            x + CELL_SIZE / 2,
            y + CELL_SIZE - 10
        );
    }

    handleCombat(currentTime) {
        this.characters.forEach(attacker => {
            // Ê™¢Êü•ÊòØÂê¶ÂèØ‰ª•ÊîªÊìä
            if (currentTime - attacker.lastAttack < 1000) return;

            // Áç≤ÂèñÊîªÊìäÁõÆÊ®ô
            const target = this.findTarget(attacker);
            if (!target) return;

            // Âü∑Ë°åÊîªÊìä
            if (attacker.type === CHARACTER_TYPES.CANNON) {
                this.createBullet(attacker, target);
            } else {
                this.meleeAttack(attacker, target);
            }
            
            attacker.lastAttack = currentTime;
        });
    }

    findTarget(attacker) {
        if (attacker.type === CHARACTER_TYPES.CANNON) {
            return this.findRangedTarget(attacker);
        } else if (attacker.type === CHARACTER_TYPES.CAT || attacker.type === CHARACTER_TYPES.SWORD_CAT) {
            return this.findMeleeTarget(attacker);
        }
        return null;
    }

    findMeleeTarget(attacker) {
        const targetPosition = attacker.team === 'BLUE' ? 
            attacker.position + 1 : 
            attacker.position - 1;

        if (targetPosition < 0 || targetPosition >= GRID_SIZE) return null;

        const targetCell = this.grid[targetPosition];
        return this.getValidTarget(targetCell, attacker.team);
    }

    findRangedTarget(attacker) {
        const direction = attacker.team === 'BLUE' ? 1 : -1;
        for (let i = 1; i <= attacker.range; i++) {
            const targetPosition = attacker.position + (i * direction);
            if (targetPosition < 0 || targetPosition >= GRID_SIZE) break;

            const targetCell = this.grid[targetPosition];
            const target = this.getValidTarget(targetCell, attacker.team);
            if (target) return target;
        }
        return null;
    }

    getValidTarget(cell, attackerTeam) {
        if (cell.fixed && cell.fixed.team !== attackerTeam) {
            return cell.fixed;
        }
        if (cell.movable && cell.movable.team !== attackerTeam) {
            return cell.movable;
        }
        return null;
    }

    meleeAttack(attacker, target) {
        target.health -= attacker.attack;
        this.checkCharacterDeath(target);
    }

    createBullet(attacker, target) {
        const direction = attacker.team === 'BLUE' ? 1 : -1;
        this.bullets.push({
            x: attacker.position * CELL_SIZE + CELL_SIZE / 2,
            y: CELL_SIZE / 2,
            targetX: target.position * CELL_SIZE + CELL_SIZE / 2,
            speed: attacker.bulletSpeed * CELL_SIZE,
            damage: attacker.attack,
            team: attacker.team,
            target: target
        });
    }

    updateBullets(deltaTime) {
        this.bullets = this.bullets.filter(bullet => {
            const dx = bullet.targetX - bullet.x;
            const distance = bullet.speed * deltaTime;
            
            if (Math.abs(dx) <= distance) {
                // Â≠êÂΩàÂëΩ‰∏≠ÁõÆÊ®ô
                bullet.target.health -= bullet.damage;
                this.checkCharacterDeath(bullet.target);
                return false;
            }

            // Êõ¥Êñ∞Â≠êÂΩà‰ΩçÁΩÆ
            bullet.x += Math.sign(dx) * distance;
            return true;
        });
    }

    checkCharacterDeath(character) {
        if (character.health <= 0) {
            // ÂæûÁ∂≤Ê†º‰∏≠ÁßªÈô§
            const cell = this.grid[character.position];
            if (character.isMovable) {
                cell.movable = null;
            } else {
                cell.fixed = null;
            }
            
            // ÂæûËßíËâ≤ÂàóË°®‰∏≠ÁßªÈô§
            const index = this.characters.indexOf(character);
            if (index > -1) {
                this.characters.splice(index, 1);
            }
        }
    }

    drawBullets() {
        this.ctx.fillStyle = 'black';
        this.bullets.forEach(bullet => {
            this.ctx.beginPath();
            this.ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
            this.ctx.fill();
        });
    }
}

// ÂïüÂãïÈÅäÊà≤
window.onload = () => {
    new Game();
}; 